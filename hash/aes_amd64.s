// Code generated by command: go run aes_asm.go -pkg hash -out ../hash/aes_amd64.s -stubs ../hash/aes_amd64.go. DO NOT EDIT.

//go:build !purego
// +build !purego

#include "textflag.h"

DATA shuffle_mask<>+0(SB)/8, $0x050f0d0806090b04
DATA shuffle_mask<>+8(SB)/8, $0x020a07000c01030e
GLOBL shuffle_mask<>(SB), RODATA|NOPTR, $16

// func aes(s string, k *uint8) uint64
// Requires: AES, AVX, SSE2, SSE4.1, SSSE3
TEXT Â·aes(SB), NOSPLIT, $0-32
	VMOVDQU shuffle_mask<>+0(SB), X10
	MOVQ    k+16(FP), AX
	VMOVDQU (AX), X11
	VMOVDQU 16(AX), X12
	VPXOR   X11, X12, X13
	MOVQ    s_base+0(FP), AX
	MOVQ    s_len+8(FP), CX

	// mix in length
	PXOR   X1, X1
	PINSRQ $0x00, CX, X1
	PADDQ  X1, X11

	// bisect the size to minimize comparisons
	CMPQ CX, $0x10
	JLE  aes_0_16
	CMPQ CX, $0x20
	JLE  aes_17_32
	CMPQ CX, $0x40
	JLE  aes_33_64

	// hash 65+ bytes
	MOVQ    AX, DX
	MOVQ    CX, BX
	ANDQ    $-64, BX
	ADDQ    AX, BX
	VMOVDQU X13, X4
	VMOVDQU X13, X5
	VMOVDQU X13, X6
	VMOVDQU X13, X7
	VMOVDQU -64(AX)(CX*1), X0
	VMOVDQU -48(AX)(CX*1), X1
	VMOVDQU -32(AX)(CX*1), X2
	VMOVDQU -16(AX)(CX*1), X3
	AESENC  X0, X4
	AESENC  X1, X5
	AESENC  X2, X6
	AESENC  X3, X7
	VMOVDQU X13, X8
	VMOVDQU X13, X9
	PADDQ   X0, X8
	PADDQ   X1, X9
	PSHUFB  X10, X8
	PADDQ   X2, X8
	PSHUFB  X10, X9
	PADDQ   X3, X9

aes_loop_64:
	VMOVDQU (DX), X0
	VMOVDQU 16(DX), X1
	VMOVDQU 32(DX), X2
	VMOVDQU 48(DX), X3
	AESENC  X0, X4
	AESENC  X1, X5
	AESENC  X2, X6
	AESENC  X3, X7
	PSHUFB  X10, X8
	PADDQ   X0, X8
	PSHUFB  X10, X9
	PADDQ   X1, X9
	PSHUFB  X10, X8
	PADDQ   X2, X8
	PSHUFB  X10, X9
	PADDQ   X3, X9
	ADDQ    $0x40, DX
	CMPQ    DX, BX
	JL      aes_loop_64

	// combine loop results
	AESENC X5, X4
	AESENC X7, X6
	AESENC X4, X11
	PSHUFB X10, X12
	PADDQ  X4, X12
	AESENC X6, X11
	PSHUFB X10, X12
	PADDQ  X6, X12
	PADDQ  X9, X8
	AESENC X8, X11
	PSHUFB X10, X12
	PADDQ  X8, X12
	JMP    aes_done

aes_33_64:
	// hash 33 to 64 bytes
	VMOVDQU (AX), X0
	VMOVDQU 16(AX), X1
	VMOVDQU -32(AX)(CX*1), X2
	VMOVDQU -16(AX)(CX*1), X3
	AESENC  X0, X11
	PSHUFB  X10, X12
	PADDQ   X0, X12
	AESENC  X1, X11
	PSHUFB  X10, X12
	PADDQ   X1, X12
	AESENC  X2, X11
	PSHUFB  X10, X12
	PADDQ   X2, X12
	AESENC  X3, X11
	PSHUFB  X10, X12
	PADDQ   X3, X12
	JMP     aes_done

aes_17_32:
	// hash 17 to 32 bytes
	VMOVDQU (AX), X0
	VMOVDQU -16(AX)(CX*1), X1
	AESENC  X0, X11
	PSHUFB  X10, X12
	PADDQ   X0, X12
	AESENC  X1, X11
	PSHUFB  X10, X12
	PADDQ   X1, X12
	JMP     aes_done

aes_0_16:
	// compare size 0 through 16
	CMPQ CX, $0x08
	JG   aes_read_9_16

	// sizes smaller than 9 won't overwrite the entire register
	PXOR X0, X0
	CMPQ CX, $0x02
	JL   aes_read_1
	CMPQ CX, $0x04
	JL   aes_read_2_3

	// read 4 to 8 bytes
	PINSRD $0x00, (AX), X0
	PINSRD $0x02, -4(AX)(CX*1), X0
	JMP    aes_hash_16

aes_read_2_3:
	// read 2 to 3 bytes
	PINSRW $0x00, (AX), X0
	PINSRB $0x08, -1(AX)(CX*1), X0
	JMP    aes_hash_16

aes_read_1:
	// read 1 byte
	CMPQ   CX, $0x01
	JL     aes_hash_16
	PINSRB $0x00, (AX), X0
	PINSRB $0x08, (AX), X0
	JMP    aes_hash_16

aes_read_9_16:
	// read 9 to 16 bytes
	PINSRQ $0x00, (AX), X0
	PINSRQ $0x01, -8(AX)(CX*1), X0

aes_hash_16:
	// hash full single XMM register
	AESENC X0, X11
	PSHUFB X10, X12
	PADDQ  X0, X12

aes_done:
	// hash final round
	VMOVDQU X12, X0
	AESDEC  X11, X0
	VMOVDQU X0, X1
	AESENC  X13, X1
	AESENC  X0, X1
	MOVQ    X1, AX
	MOVQ    AX, ret+24(FP)
	RET
